#ifndef ABRTOS_WDT_SUPPORT
#define ABRTOS_WDT_SUPPORT

#define ABRTOS_MOD		ABRTOS_LOG_MOD_WDT

#define	ABRTOS_WDT_SETUP_STARTED			0
#define	ABRTOS_WDT_SETUP_COMPLETED			1
#define	ABRTOS_WDT_RESET_START				2
#define	ABRTOS_WDT_RESET_FINISH				3
#define	ABRTOS_WDT_STARTUP_CHECK_START		4
#define	ABRTOS_WDT_STARTUP_CHECK_FINISH		5
#define	ABRTOS_WDT_START_START				6
#define	ABRTOS_WDT_START_FINISH				7
#define	ABRTOS_WDT_FEED_START				8
#define	ABRTOS_WDT_FEED_FINISH				9
#define	ABRTOS_WDT_SET_MODE_START			10
#define	ABRTOS_WDT_SET_MODE_FINISH			11
#define	ABRTOS_WDT_THE_DOG_WAS_FED			12

FUNCTION ABRTOS_WDT_PRIV_GET_TC_REG AS INTEGER
' RETURNS THE VALUE OF THE ABRTOS_WDT'S TIME CONSTANT THAT IS RELOADED UPON FEEDING...
	RETURN ABRTOS_WDT_TC_REG

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_PRIV_GET_TIME_REG AS INTEGER
' RETURNS THE VALUE OF THE ABRTOS_WDT'S COUNT-DOWN REGISTER
	RETURN ABRTOS_WDT_TIME_REG

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_PRIV_SET_TC_REG(ABRTOS_WDT_TC AS INTEGER) AS INTEGER
' SETS, READS, & RETURNS THE ABRTOS_WDT_TC_REG THAT WAS JUST SET, AS A VALIDATION...
	ABRTOS_WDT_TC_REG = ABRTOS_WDT_TC
	RETURN ABRTOS_WDT_PRIV_GET_TC_REG
	
ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_PRIV_GET_STATE AS INTEGER
' RETURNS THE CONTENTS OF THE WDMOD REG
	RETURN ABRTOS_WDT_MODE_REG
	
ENDFUNCTION

'==============================================================================

SUB ABRTOS_WDT_FEED_THE_DOG
' RESETS THE ABRTOS_WDT'S COUNT-DOWN REGISTER WITH THE VALUE STORED IN ABRTOS_WDT_TC_REG
	ABRTOS_WDT_FEED_REG = ABRTOS_WDT_F00D_BYTE1
	ABRTOS_WDT_FEED_REG = ABRTOS_WDT_F00D_BYTE2
	
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_THE_DOG_WAS_FED)
	#endif
	

ENDSUB

'==============================================================================

FUNCTION ABRTOS_WDT_MS_WDTC AS INTEGER

' 1 <= RETURN_VAL <= 1145324
' WHICH IS 1MS TO ~ 19 MINUTES 5.324 SECONDS WITH 1MS RESOLUTION

' THE FUNCTION RETURNS THE ABRTOS_WDT'S TIME CONSTANT IN MS

		RETURN (ABRTOS_WDT_PRIV_GET_TC_REG / ABRTOS_WDT_MS_RESOLUTION_MULTIPLIER)

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_SET_WDTC(ABRTOS_WDT_TC_MS AS INTEGER) AS INTEGER

' VALID PARAMETER RANGE: 1 <= ABRTOS_WDT_TC_MS <= 1145324
' WHICH IS 1MS TO ~ 19 MINUTES 5.324 SECONDS WITH 1MS RESOLUTION

' THE FUNCTION RETURNS THE ABRTOS_WDT'S TIME CONSTANT JUST SET, IN MS, AS VALIDATION,
' OR -1 IF SOMETHING WENT AWRY...

' FORCED BOUNDING OF THE PASSED PARAMETER

	IF ABRTOS_WDT_TC_MS < 1 THEN
		ABRTOS_WDT_TC_MS = 1
	ELSEIF ABRTOS_WDT_TC_MS > 1145324
		ABRTOS_WDT_TC_MS = 1145324
	ENDIF

'SET, CHECK, AND RETURN
	
	IF (ABRTOS_WDT_PRIV_SET_TC_REG(ABRTOS_WDT_TC_MS * ABRTOS_WDT_MS_RESOLUTION_MULTIPLIER)) <> (ABRTOS_WDT_TC_MS * ABRTOS_WDT_MS_RESOLUTION_MULTIPLIER) THEN
		' TO-DO:  SHOULD PROLLY DISABLE THE ABRTOS_WDT AS A WHOLE IF IT IS NON-COMPLIANT HERE.?.
		RETURN -1
	ELSE
		RETURN ABRTOS_WDT_MS_WDTC
	ENDIF

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_MS_TO_UNDERFLOW AS INTEGER
' RETURNS THE VALUE OF THE ABRTOS_WDT'S COUNT-DOWN REGISTER IN MS
' I.E. HOW LONG THE USER CODE HAS TO FEED THE DOG BEFORE A FORCED RESET...
	RETURN (ABRTOS_WDT_PRIV_GET_TIME_REG / ABRTOS_WDT_MS_RESOLUTION_MULTIPLIER)

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_TO_FLAG(ABRTOS_CLEAR_WDTOF AS INTEGER) AS INTEGER

' RETURNS THE VALUE OF THE ABRTOS_WDT'S TIME OUT FLAG IN WDCON REG
' NEED TO SEE IF THIS ALSO CLEARS THE RESET SOURCE IDENTIFIER REGISTER IN SYSCON
' IF SET, CLEARS THE FLAG IF NON-ZERO PRAM PASSED, AND RETURNS A 1 - ELSE IT RETURNS A ZERO
'
' THE USEFULNESS OF THIS MAY ONLY BE WHEN THE ABRTOS_WDT IS IN INTERRUPT MODE (I.E. FOR DEBUGGING
' OR FOR USING THE ABRTOS_WDT IN A NON-RESET CAPACITY, AND A NON INTERRUPT CAPACITY (AS IS THE CASE
' WITH ARMBASIC V7)).  SO, CURRENTLY, THE USER CODE MUST POLL THIS FLAG AND REACT TO IT, WHEN
' NOT USING THE RESET MODE OF THE ABRTOS_WDT...
'
' CURRENTLY IN V7 ARMbasic, THE VIC HAS THE WDINT DISABLED, SO THIS MIGHT BE A GOOD
' TOOL TO USE TO SEE IF THE ABRTOS_WDT TIMED OUT WITHOUT ENABLING THE RESET MODE.?.
' I DUNNO IF THIS CAN BE ALTERED BY ANY ACTIVITIES IN THE VIC AND/OR SYSCON YET...

	IF (ABRTOS_WDT_PRIV_GET_STATE AND ABRTOS_WDT_FLAG_BIT_MASK AND ABRTOS_WDT_STATUS_TO_FLG_PTR) THEN
		IF ABRTOS_CLEAR_WDTOF THEN ABRTOS_WDT_MODE_REG = ABRTOS_WDT_MODE_REG AND $03
		RETURN 1
	ELSE
		RETURN 0
	ENDIF

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_INT_FLAG AS INTEGER

' RETURNS THE VALUE OF THE ABRTOS_WDT'S INTERRUPT FLAG IN WDCON REG
' IF SET, RETURNS A 1, ELSE RETURNS A 0.
' THIS IS A READ-ONLY BIT IN WDCON - IT IS CLEARED WHEN ANY RESET OCCURS
' THUS THE USEFULNESS OF THIS MAY ONLY BE WHEN THE ABRTOS_WDT IS IN INTERRUPT MODE (I.E. DEBUGGING).
' CURRENTLY IN V7 ARMbasic, THE VIC HAS THE WDINT DISABLED, SO THIS MIGHT BE A GOOD
' TOOL TO USE TO SEE IF THE ABRTOS_WDT TIMED OUT WITHOUT ENABLING THE RESET MODE.?.
' I DUNNO IF THIS CAN BE ALTERED BY ANY ACTIVITIES IN THE VIC AND/OR SYSCON YET...
' ALSO, THERE IS DISCUSSION OF ENABLING ab'S VIC WDINT FUNCTIONALITY IN FUTURE RELEASES.

	IF (ABRTOS_WDT_PRIV_GET_STATE AND ABRTOS_WDT_FLAG_BIT_MASK AND ABRTOS_WDT_STATUS_INT_FLG_PTR) THEN
		RETURN 1
	ELSE
		RETURN 0
	ENDIF

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_STATUS
'RETURN THE FLAG BITS OF THE WDCON REGISTER
	RETURN ABRTOS_WDT_PRIV_GET_STATE AND ABRTOS_WDT_FLAG_BIT_MASK
	
ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_MODE

	RETURN (ABRTOS_WDT_PRIV_GET_STATE AND ABRTOS_WDT_MODE_BIT_MASK)

ENDFUNCTION

'==============================================================================

FUNCTION ABRTOS_WDT_SET_MODE(ABRTOS_WDT_MD AS INTEGER) AS INTEGER
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_SET_MODE_START)
	#endif
	
	SELECT ABRTOS_WDT_MD
	
		CASE ABRTOS_WDT_MODE_DISABLED
				' THE VALUE OF THIS CASE IS PRETTY USELESS AS BY DEFAULT, THE ABRTOS_WDT
				' IS DISABLED AT BOOTUP.  WDMOD MODE BITS ARE SET ONLY, NO RESET,
				' SO ONCE THE ABRTOS_WDT IS OUT OF DISABLED MODE, THERE IS NO GOING BACK...
				' HOWEVER, THIS CASE WILL REMAIN IN THE LIB, IN CASE A FUTURE REV
				' OF THE DEVICE ALLOWS FOR RESETTING THE MODES.
				' I SUSPECT THAT THEY DIDN'T WANT THE ABILITY FOR ROGUE CODE TO
				' BE ABLE TO CLEAR A WATCHDOG EVENT FROM HAPPENING, HENCE I DO GET
				' WHY THE MODE SETTING IS A ONE-WAY STREET...
			ABRTOS_WDT_MODE_REG = (ABRTOS_WDT_MODE_BIT_MASK AND ABRTOS_WDT_MODE_DISABLED)
			IF ABRTOS_WDT_MODE <> ABRTOS_WDT_MODE_DISABLED THEN
				RETURN -1
			ENDIF
			
		CASE ABRTOS_WDT_MODE_INTERRUPT
			ABRTOS_WDT_MODE_REG = (ABRTOS_WDT_MODE_BIT_MASK AND ABRTOS_WDT_MODE_INTERRUPT)
			IF ABRTOS_WDT_MODE <> ABRTOS_WDT_MODE_INTERRUPT THEN
				' WDMOD MODE BITS ARE SET ONLY, NO RESET,
				' SO ONCE THE ABRTOS_WDT IS IN INTERRUPT MODE THERE IS NO GOING BACK, AND
				' THERE IS NOT ANY WAY TO GET TO INTERRUPT MODE FROM RESET MODE...
				' I SUSPECT THAT THEY DIDN'T WANT THE ABILITY FOR ROGUE CODE TO
				' BE ABLE TO CLEAR A WATCHDOG EVENT FROM HAPPENING, HENCE I DO GET
				' WHY THE MODE SETTING IS A ONE-WAY STREET...
				RETURN -1  ' MOST LIKELY IN RESET MODE - NO GETTING BACK FROM THERE...
			ENDIF
			
		CASE ABRTOS_WDT_MODE_RESET
			ABRTOS_WDT_MODE_REG = (ABRTOS_WDT_MODE_BIT_MASK AND ABRTOS_WDT_MODE_RESET)
			IF ABRTOS_WDT_MODE <> ABRTOS_WDT_MODE_RESET THEN
				' WDMOD MODE BITS ARE SET ONLY, NO RESET,
				' SO ONCE THE ABRTOS_WDT IS IN RESET MODE THERE IS NO GOING BACK, AND
				' THERE IS NOT ANY WAY TO GET TO INTERRUPT MODE FROM RESET MODE...
				' I SUSPECT THAT THEY DIDN'T WANT THE ABILITY FOR ROGUE CODE TO
				' BE ABLE TO CLEAR A WATCHDOG EVENT FROM HAPPENING, HENCE I DO GET
				' WHY THE MODE SETTING IS A ONE-WAY STREET...
				RETURN -1
			ENDIF
			
		CASE ELSE
			RETURN -1
			
	ENDSELECT
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_SET_MODE_FINISH)
	#endif
	
	RETURN ABRTOS_WDT_MODE

ENDFUNCTION

'==============================================================================

SUB ABRTOS_WDT_POSTRESET_HANDLER

	PRINT
	PRINT "A WATCHDOG RESET TOOK PLACE..."
	ABRTOS_WDT_TO_FLAG(1)
	PRINT "WATCHDOG TIMEOUT FLAG IS NOW CLEARED."
	PRINT

ENDSUB

'==============================================================================

SUB ABRTOS_WDT_POSTINT_HANDLER

	PRINT
	ABRTOS_WDT_TO_FLAG(1)  'WHEN THE INT IS TOSSED, THE WDTO FLAG IS ALSO SET - SO CLEAR IT
					' OR YOU'LL BE SERVICING THE INT 4 EVER...
	PRINT "THE WATCHDOG DID NOT GET FED IN TIME AND AS A RESULT,"
	PRINT "A WATCHDOG UNDERFLOW TOOK PLACE, TOSSING AN WDINT..."
	PRINT

ENDSUB

'==============================================================================

SUB ABRTOS_WDT_RESET
' FORCES RESET IN VERY SHORT TIME - SET THE TC TO THE MINIMUM...
' THE CODE HAD BETTER HAVE A HANDLER, OR THIS COULD GET UGLY AND BE DIFFICULT TO GET AHOLD OF...
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_RESET_START)
	#endif
	
	ABRTOS_WDT_PRIV_SET_TC_REG($FF)
	ABRTOS_WDT_SET_MODE(ABRTOS_WDT_MODE_RESET)
	ABRTOS_WDT_FEED_THE_DOG
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_RESET_FINISH)
	#endif
	
ENDSUB

'==============================================================================

SUB ABRTOS_WDT_STARTUP_CHECK
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_STARTUP_CHECK_START)
	#endif
	

	IF ABRTOS_WDT_INT_FLAG THEN
		ABRTOS_WDT_POSTINT_HANDLER
		ABRTOS_STOP_FLAG = 1
		'TOSS ERROR HERE?
	ELSEIF ABRTOS_WDT_TO_FLAG(0) THEN 
		ABRTOS_WDT_POSTRESET_HANDLER
		ABRTOS_STOP_FLAG = 1
		'TOSS ERROR HERE?
	ENDIF
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_STARTUP_CHECK_FINISH)
	#endif
		
ENDSUB

'==============================================================================

SUB ABRTOS_WDT_SETUP
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_SETUP_STARTED)
	#endif
	
	ABRTOS_WDT_SET_WDTC(ABRTOS_WDT_TEST_TC)
	ABRTOS_WDT_SET_MODE(ABRTOS_WDT_MODE_CNTL)
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_SETUP_COMPLETED)
	#endif
	
ENDSUB

'==============================================================================

SUB ABRTOS_WDT_START
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_START_START)
	#endif
	
	ABRTOS_WDT_FEED_THE_DOG
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_START_FINISH)
	#endif
	
ENDSUB

'==============================================================================

SUB ABRTOS_WDT_FEED
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_FEED_START)
	#endif
	
	ABRTOS_WDT_FEED_THE_DOG
		
	#if ABRTOS_OPTION_USE_LOGGING == 1
		ABRTOS_LOG_EVENT(ABRTOS_MOD,ABRTOS_WDT_FEED_FINISH)
	#endif
	
ENDSUB

'==============================================================================

#endif
