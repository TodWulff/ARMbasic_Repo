#ifndef ARMbasic_Extensions
#define ARMbasic_Extensions

'TO DO:  Have #ifdef conditional to load segments of this extension vs. the whole damn thing
'or split it to separate sub-lib files (te ease mx and future reuse)

' Aug'18 comments - ripped out filepp maths stuff, bitbanged & shared spi stuff, and random stuff,

#define GlbStrLenLim 48
Const GlbStr_Lim = GlbStrLenLim
dim Global$(GlbStrLenLim) as string	' // a GlbStr_Lim byte scratchpad that can be used as deemed fit by any functions - contents volatile
dim NStr(1) as string
dim NInt as integer
dim NSgl as single
dim PIN_DATA_DIR_REG as integer

'==============================================================================
 '-------------------- ARMBASIC GENERIC DEFINITIONS--------------- 2012-05-20
'==============================================================================
#define one 1
#define One 1
#define ONE 1
#define zero 0
#define Zero 0
#define ZERO 0
#define hi ONE
#define Hi ONE
#define HI ONE
#define lo ZERO
#define Lo ZERO
#define LO ZERO
#define outp HI
#define Outp HI
#define OUTP HI
#define inpt LO
#define Inpt LO
#define INPT LO
#define false LO
#define False LO
#define FALSE LO
#define true ((NOT(FALSE)) and 1)
#define True ((NOT(FALSE)) and 1)
#define TRUE ((NOT(FALSE)) and 1)

#define PEEK(addr) (*(addr)) ' the () ensure only addr is used in the address calculation
#define POKE(addr,value) *(addr) = value

#define paws pauze
'==============================================================================
'---------------------- ARMBASIC DEBUG EXTENSIONS ------------------ 2007-08-02
'==============================================================================
#define debug	DEBUG
#define Debug	DEBUG
#define production PRODUCTION
#define Production PRODUCTION

#if enabledebug != 0		' need to be #def'd prior to including this lib...
	#include "__lib/debugger.lib"
	#define DEBUG(args...)	args
	#define PRODUCTION(args...)
	#warning " "
	#warning "DEBUG FACILITIES ARE ENABLED"
	#warning " "
#else
	#define DEBUG(args...)
	#define PRODUCTION(args...)	args
	#warning " "
	#warning "DEBUG FACILITIES ARE DISABLED"
	#warning " "
#endif
'==============================================================================
'-------------------- ARMBASIC BITWISE EXTENSIONS ------------------ 2007-08-02
'==============================================================================
#define  bittest	 BITTEST
#define  setbit		 SETBIT
#define  clrbit		 CLRBIT
#define  tglbit		 TGLBIT
#define  bit2io	 	BIT2IO
#define  _bit2io	_BIT2IO
#define  bitxfer	 BITXFER
#define  _bitxfer	_BITXFER
#define  io2bit	 	IO2BIT
#define  _io2bit	_IO2BIT

#define  BitTest	 BITTEST
#define  SetBit		 SETBIT
#define  ClrBit		 CLRBIT
#define  TglBit		 TGLBIT
#define  Bit2IO	 	BIT2IO
#define  _Bit2IO	_BIT2IO
#define  BitXfer	 BITXFER
#define  _BitXfer	_BITXFER
#define  IO2Bit	 	IO2BIT
#define  _IO2Bit	_IO2BIT

#define  Bittest	 BITTEST
#define  Setbit		 SETBIT
#define  Clrbit		 CLRBIT
#define  Tglbit		 TGLBIT
#define  Bit2io	 	BIT2IO
#define  _Bit2io	_BIT2IO
#define  Bitxfer	 BITXFER
#define  _Bitxfer	_BITXFER
#define  Io2bit	 	IO2BIT
#define  _Io2bit	_IO2BIT

#define BITTEST(REG,BIT)  		(1 and ((REG AND (1 << BIT)) >> BIT))		' RETURNS A 1 IF SET,0 IF CLR
#define SETBIT(REG,BIT)   		REG = REG OR (1 << BIT)				' SETS BIT
#define CLRBIT(REG,BIT)   		REG = REG AND NOT (1 << BIT)		' CLEARS BIT
#define TGLBIT(REG,BIT)			REG = REG XOR (1<<BIT)				' TOGGLES BIT
#define  BIT2IO(REG,BIT,PORT)	OUT(PORT) = BITTEST(REG,BIT)		' SETS PORT TO BIT IN REG
#define _BIT2IO(REG,BIT,PORT)	OUT(PORT) = NOT(BITTEST(REG,BIT))	' SETS PORT TO NOT OF BIT IN REG
#define  BITXFER(SRCREG,SRCBIT,TGTREG,TGTBIT)	TGTREG = (TGTREG AND NOT (1 << TGTBIT)) OR (((1<<SRCBIT) AND SRCREG)<<TGTBIT)	' SETS TGTREG/TGTBIT TO SRCREG/SRCBIT
#define _BITXFER(SRCREG,SRCBIT,TGTREG,TGTBIT)	TGTREG = (TGTREG AND NOT (1 << TGTBIT)) OR (((1<<SRCBIT) AND NOT(SRCREG))<<TGTBIT)	' SETS TGTREG/TGTBIT TO NOT SRCREG/SRCBIT
#define  IO2BIT(REG,BIT,PORT)  	REG = (REG AND NOT (1 << BIT)) OR ((1<<BIT) AND IN(PORT))	' SETS BIT OF REG TO PORT STATE
#define _IO2BIT(REG,BIT,PORT)  	REG = (REG AND NOT (1 << BIT)) OR ((1<<BIT) AND NOT(IN(PORT)))	' SETS BIT OF REG TO NOT PORT STATE
'==============================================================================
'-------------------- FLOATING POINT EXTENSIONS ---------------- 2012-05-19
'==============================================================================
Const	 qnan		=	$7FC00000
Const	 nqnan		=	$FFC00000
Const	 inf		=	$7F800000
Const	 ninf		=	$FF800000
Const	 snan		=	$7F800001
Const	 nsnan		=	$FF800001
Const	 fzero		=	$00000000
Const	 nzero		=	$80000000

#define	 qnan_binS	 "01111111110000000000000000000000"	' $7FC00000
#define	 nqnan_binS	 "11111111110000000000000000000000" ' $FFC00000

#define	 infin_binS	 "01111111100000000000000000000000" ' $7F800000
#define	 ninfin_binS "11111111100000000000000000000000" ' $FF800000

#define	 snan_binS	 "01111111100000000000000000000001" ' $7F800001
#define	 nsnan_binS	 "11111111100000000000000000000001" ' $FF800001

#define	 fzero_binS	 "00000000000000000000000000000000" ' $00000000
#define	 nzero_binS	 "10000000000000000000000000000000" ' $80000000
'==============================================================================
' #define qnan			$7FC00000
' #define nqnan			$FFC00000
' #define inf			$7F800000
' #define ninf			$FF800000
' #define snan			$7F800001
' #define nsnan			$FF800001
' #define fzero			$00000000
' #define nfzero			$80000000
' Const	 qnan_binS		=	"01111111110000000000000000000000"	' 7FC00000
' Const	 nqnan_binS	=	"11111111110000000000000000000000" ' FFC00000
' Const	 infin_binS	=	"01111111100000000000000000000000" ' 7F800000
' Const	 ninfin_binS	=	"11111111100000000000000000000000" ' FF800000
' Const	 snan_binS		=	"01111111100000000000000000000001" ' 7F800001
' Const	 nsnan_binS	=	"11111111100000000000000000000001" ' FF800001
' Const	 zero_binS		=	"00000000000000000000000000000000" ' 7F800001
' Const	 nzero_binS	=	"10000000000000000000000000000000" ' FF800001
'==============================================================================
function fSpec (fParam as single) as single 'presumably used to test float parameters passed
	if (fParam = qnan) then return qnan
	' if (fParam = nqnan) then return nqnan
	' if (fParam = inf) then return inf
	' if (fParam = ninf) then return ninf
	' if (fParam = fzero) then return fzero
	return 0
	endfunction
'==============================================================================
function isqnan(num as single) as integer  'return -1 for -qNaN, O for not qNaN, and +1 for +qNaN
		' print "num: ";IHEXL(num),"qnan: ";IHEXL(qnan),"and'd: ";IHEXL(num and qnan) 
		' print "isqnan num: ";num,
		' print IHEXL(num),
		' print "isqnan num: ";*(addressof num),
		' print qnan, IHEXL(*(addressof num)),
		if (*(addressof num) and qnan) = qnan then return 1
		if (*(addressof num) and nqnan) = nqnan then return -1
		return 0
		endfunction
'==============================================================================
function isinf(num as single) as integer  'return -1 for -Inf, O for not Inf, and +1 for +Inf
		' print "num: ";num,
		if (*(addressof num) and inf) = inf then return 1
		if (*(addressof num) and ninf) = ninf then return -1
		return 0
		endfunction
'==============================================================================
function issnan(num as single) as integer  'return -payload for -sNaN, O for not sNaN, and +payload for +sNaN
	// fix me - get teh payload and be sure to return it?
		
		' print "num: ";num,
		if (*(addressof num) and snan) = snan then return 1
		if (*(addressof num) and nsnan) = nsnan then return -1
		return 0
		endfunction
'==============================================================================
function iszero(num as single) as integer  'return -1 for -0.0, 0 for not Zero, and +1 for +Zero
		' print "num: ";num,
		if *(addressof num) = fzero then return 1
		if (*(addressof num) and nzero) = nzero then return -1
		return 0
		endfunction
'==============================================================================
' add moar helpers to check for isnan and isnaninf
'==============================================================================
' Conversion functions
'==================================================================================================================
function b2i(byval bin_str(32) as string) as integer
	dim index as integer
	dim iVal as integer
	index = 0
	iVal = 0
	while len(bin_str) <32
		bin_str = "0" & bin_str
		loop
	while index < 32
		if bin_str(index) = "1" then setbit(iVal,31-index)
		index = index + 1
		loop
	return iVal
	endfunction
'==============================================================================
function b2f(byval bin_str(32) as string) as single
	dim index as integer
	dim iVal as single
	dim temp as integer
	index = 0
	iVal = 0
	temp = 0
	while len(bin_str) <32			' pad on zeros to get len to 32
		bin_str = "0" & bin_str
		loop
	while index < 32
		if bin_str(index) = "1" then setbit(temp,31-index)
		index = index + 1
		loop
	*(addressof iVal) = temp
	return iVal
	endfunction
'==============================================================================
Function a2f(byref strg as string) as single				// for converting string to float

	// a function for ARMbasic v8.x+ where a string representation of a number is processed and a single is returned.
	// supports number enteries such as: 1, -1.2, 123.4e-2, 1e1, 1.e+004.05 (note fractional portions of the power of 10 is discarded as it is illegal to do so anyways...)
	// even an entry such as	-   0  1 2 33 6 5  .  10001 e +-003.2-34	is processed and the result returned is   -123.3651
	
	//  Useage example:  
		' print "Enter a real number (+/- integer or single (can include +/- e-notation too): ";
		' debugin inputstring
		' print inputstring
		' print 
		' print "Value derived: ";a2f(inputstring)
		' print

	// surprisingly, we actually need quite a few vars to track all the shite we're tracking herein
	dim valu,power,exp_pwr,exp_valu as single
	dim i, i1, i2, i3, sign, exp_sign, str_end, tempint as integer
	if strg="" then return snan
	// and we need to set up some valid starting points for things...
	valu  = 0.0			// the numerical representation of the integral and decimal portions of the mantissa
	sign = 0				// the sign of the mantissa
	power = 1.0			// this is used to help properly place the decimal in the mantissa after processing the whole string
	exp_valu = 0.0			// this is the numerical representation of the integral and decimal portions of the e-notation's power of 10
	exp_pwr = 1.0			// like above this is used to help properly place the decimal in the enotation's power of 10 after processing the string for same.;
	exp_sign = 0			// the sign of the e-notation's power of 10 - i.e. the '-' in 1234E-3
	str_end = len(strg)-1	// calculate this once and use the var below - code saver...
	for i = 0 to str_end									// and here we go - clackity clack, then the strange silence as gravity pulls you over the top and down the rails...
		if (i=0) and ((strg(i)="e") or (strg(i)="E")) then return 0.0	// with no mantissa before the exponent, simply return 0.0
		if strg(i)="+" then i += 1							// ignore + and increment the index so that the next char can be processed by this iteration of the loop...
		if(strg(i)="-") then sign -= 1						// gotta keep track if the user entered a negative number...
		if (strg(i)>="0") and (strg(i)<="9") 
			tempint = strg(i)-"0"
			valu=10.0*valu+(tempint)  // build the val of the integral mantissa
			endif
		if ((strg(i)="e") or (strg(i)="E"))					// deal with inputs of the form 1e05 (no decimal in the mantissa)
			i-=1												// ... the mantissa is done and we got the value for it to this point
			strg(i)="."										// so simulate a decimal to trigger the following code
			endif
		if strg(i) = "."										// ok, we're goin fractional
			i += 1												// bump to the next char past the '.'
			for i1 = i to str_end							// and jump into a sub loop to parse the rest of the string
				i += 1											// need to inc the index of the outer loop(s) since we are processing in a sub-loop
				if (strg(i1)>="0") and (strg(i1)<="9")		// if the char is part of a number
					power*=10.0								// keep track of the post-decimal depth, so we can divide the integer decimal to arrive at the real decimal val
					tempint = strg(i1)-"0"
					valu=10.0*valu+(tempint)			// and build an integer representation of the decimal portions...
					endif
				if ((strg(i1)="e") or (strg(i1)="E")) 		// if we arrive at an e or an E then we jump yet again into a sub loop to pocoess e-notation
					i += 1										// bump the outer indicies to get past the e/E
					i1+=1										// ...
					for i2 = i1 to str_end				// and grind thru the rest of the string
						i+=1									// and continue to keep the outer indicies updated to where we are at
						i1+=1									// ...
						if(strg(i2)="-") then exp_sign -= 1		// if there is a - sym in the enotation, negate the enotation
						if (strg(i2)>="0") and (strg(i2)<="9")
							tempint = strg(i2)-"0"
							exp_valu=10.0*exp_valu+(tempint) // and build the mantissa portions of the enotation
							endif
						if strg(i2) = "."						// yes, I said mantissa as it is possible that someone could get the bright idea to try to do fractional powers of 10...
							i += 1								// and if they do, we need to process it as such, so that we can throw it away later, vs. concatenating and really screwing things up...
							i1+=1								// bump the outer indicies to get past the enotation's decimal point
							i2+=1								// ...
							for i3 = i2 to str_end		// and here we go with fractional enotation component parsing
								i += 1							// since we are into yet another subloop we must keep the outer indicies updated,
								i1+=1							// ...
								i2+=1							// ...
								if (strg(i3)>="0") and (strg(i3)<="9")		// if the char is part of a number
									exp_pwr*=10.0								// keep track of the post-decimal value, so we can divide the integer decimal to arrive at the real decimal val
									tempint = strg(i3)-"0"
									exp_valu=10.0*exp_valu+(tempint)  // and build an integer representation of the decimal portions of the enotation...
									endif
								next i3
							endif
						next i2
					exp_valu = (exp_valu/exp_pwr)*if(exp_sign<0,-1,1)		// at this level we are done processing the enotation portions of the construct and we create a proper single representing the enotation's power of 10, integer and decimal portion
					endif
				next i1
			endif
		next i
		exp_pwr = 1					// using this single to become our value to multiply the real mantissa by.  For the record, 10^0 = 1 so this is a perfect default, in case there is not any enotation and we fall right through to the return.
		if exp_sign < 0				// if power of 10 is <0, then we are needing to move the decimal left (much like calling Cadence in the Marine Corps, 'LEFT, LEFT, LEFT aighty LEFT)
			while (exp_valu <= -1)	// not using < 0  to get rid of fractional exponent portions of the enotation's power of 10
				exp_pwr/=10			// so while we are still negative powered, move the multiplier's decimal more left
				exp_valu+=1.0			// and keep track of how less negative in power we are
				loop					// until we are done and have arrived at a good multiplier...
		else							// so we are either a 0 power of 10, which case well fall thru, or a positive power of 10 and gotta shuffle to the right (To the RIGHT, my conservative Brothas. To the RIGHT!!!)
			while exp_valu >= 1		// not using > 0  to get rid of fractional exponent portions of the enotation's power of 10
				exp_pwr*=10			// same principles at a negative powers of 10, except we are moving the decimal to the right now.
				exp_valu-=1.0			// and keeping track of how much more positive in power we are
				loop					// until we are done and have arrived at a good multiplier...
		endif	
		return (valu/power)*if(sign<0,-1,1)*exp_pwr	// and we finally get to do the math to return a single that was converted from a string that may have included a integral and fractional portion of a mantissa and also possibly a integral and fractional portion of a e-notated power of 10...  Woo Hoo.!.
		

	endfunction
'==============================================================================
Function a2i(byref strg as string) as integer				// for converting string to float
	// a function for ARMbasic v8.x+ where a string representation of a number is processed and an integer is returned.
	return a2f(strg)	' return an integer as per the func def...
	endfunction
'==============================================================================
Function old_a2f(byref strg as string) as single
	dim valu,power as single
	dim i, i1, sign, tempint as integer
	valu  = 0.0
	power = 1.0
	sign = 0
	for i = 0 to len(strg)-1
		if(strg(i)="-") then sign = sign - 1 // i -= 1 borked here (w/ paren'd cond) 
		if strg(i)="+" then i = i + 1  // i += 1 borked here 
		if (strg(i)>47) and (strg(i)<58)
			tempint = strg(i)-"0"
			valu=10.0*valu+(tempint)
			endif
		if strg(i) = "."
			i += 1
			for i1 = i to len(strg)-1
				i += 1
				if ((strg(i1)>47) and (strg(i1)<58))
					power*=10.0
					tempint = strg(i1)-"0"
					valu=10.0*valu+(tempint)
					endif
				next i1
		endif
		next i
	return (valu/power)*if(sign<0,-1,1)
	endfunction
'==============================================================================
'  User Input Functions with prompts, for Strings, Integers, or Floats.
'
' // except at detailedl below DO NOT pass (string) constants - these functions writes to the 
' // passed pointers setting it to the user's input as a desired by-product in case the calling 
' // code needs access to exactly what was typed and not just the parsing results...
'
' to make use of this code properly, inside of main, or an init function/sub, call the following init_abe
' sub, to instaniate the correct initial state for some special variables, used to denote when
' the programmer passed a 'null' variable, to prevent the function from overwriting an other-
' wise good variable, had it been passed.
'
' for integer functions where there is no int var to set when calling, pass NInt
' for float functions, where there is no single var to set when calling, pass NSgl
' for string functions, where there is no string var to set when called, pass NStr
' these are set to their initial values in the following sub...
'
' I could do away with this by having another set of functions without the var being passed
' but decided against doing so at this point in time.  Why?  Because, figuring it out was a bit2io
' of a good challenge and I am tired...
'
'==============================================================================
sub init_abe  ' READ COMMENTS ABOVE THIS LINE  <<--== ##  LOOK!
	NInt = $FF800001					'Null Integer - same binary representation as snan
	*(addressof NSgl)  = nsnan	'Null Single - snan...
	NStr=""								'Null String
	pin_data_dir_reg = 0
	endsub
'==============================================================================
function _uinput(byref str_pmpt as string) as string
	print str_pmpt
	debugin Global$
	return Global$
	endfunction
'==================================================================================================================
function uinputs (byref str_pmpt as string, byref str_var as string) as string
// 	use:  uinputs("enter the string:):", svar)
		DEBUG(print "str_var address and value: ",addressof str_var, *(addressof str_var))
		DEBUG(print "NStr address and value: ",addressof NStr, *(addressof NStr))
	if (*(addressof str_var) = (addressof NStr)) ' no var to set, just return the val
		DEBUG(print "NStr detected.")
		Global$ = _uinput(str_pmpt)
		return Global$
	else															' set the var and return the val
		DEBUG(print "Proper String variable.")
		str_var =_uinput(str_pmpt)
		return str_var
		endif
	endfunction
'==============================================================================
function uinputi (byref str_pmpt as string, byref int_var as integer) as integer
// 	use:  uinputi("enter an integer (32bit signed):", starti)
	dim tmp_int as integer
		DEBUG(print "int_var address and value: ",addressof int_var, *(addressof int_var))
		DEBUG(print "NInt address and value: ",addressof NInt, *(addressof NInt))
		DEBUG(Print "passed: ";int_var, "test: ";nsnan)
	if (int_var = nsnan) ' no var to set, just return the val
		DEBUG(print "NInt detected.")
		global$ = _uinput(str_pmpt)
		tmp_int = a2i(global$)
		return tmp_int
	else															' set the var and return the val
		DEBUG(print "Proper Integer variable.")
		global$ = _uinput(str_pmpt)
		int_var=a2i(global$)
		return int_var
		endif
	endfunction
'==============================================================================
function uinputf(byref str_pmpt as string, byref sgl_var as single) as single		// for user input of floats
// 	use:  starti = uinputi("enter the float val (32bit ieee754):")
	dim tmp_sgl as single
		DEBUG(print "sgl_var address and value: ",addressof sgl_var, *(addressof sgl_var))
		DEBUG(print "NSgl address and value: ",addressof NSgl, *(addressof NSgl))
		DEBUG(Print "passed: ";sgl_var, "test: ";nsnan)
	if issnan(sgl_var) ' no var to set, just return the val
		DEBUG(print "NSgl detected.")
		global$ = _uinput(str_pmpt)
		tmp_sgl = a2f(global$)
		return tmp_sgl
	else															' set the var and return the val
		DEBUG(print "Proper Float variable.")
		global$ = _uinput(str_pmpt)
		sgl_var=a2f(global$)
		return sgl_var
		endif
	endfunction
'==================================================================================================================
function old_uinputf (byref str_pmpt as string) as single
// 	use:  starti = uinputi("enter the float val (32bit ieee754):")
	dim ret_val as single
	print str_pmpt;" (len<=";GlbStrLenLim;"): ";
	debugin Global$
	ret_val = a2f(Global$)
	print Global$;" | ";ret_val
	return ret_val
	endfunction
'==============================================================================
function uinputf2 (byref str_pmpt as string, byref some_val as single) as single
' // use:  uinputi("enter the float val (32bit ieee754):", starti)
	print str_pmpt;" ";			// print the prompt
	debugin Global$				// get the user input string using the byref'd var
	some_val = a2f(str_pmpt)	// set the value of the passed single to the value of the entered string
	print Global$;" | ";some_val	// echo the user's input & converted to a number (confirmming feedback)
	return some_val				// and return the value in the event that this function was part of an expression
	endfunction
'==============================================================================
sub halt  'suspends operations and drops out of the runtime to enable debugging via BT - user must press run to continue...
	print
	print "Execution is to be halted.  You'll need to click on Run to resume execution.  ...  Halted."
	print
	stop
	endsub
'==============================================================================
sub pauze 'just throws a promp and awaits for user entry of a carriage return...
	DIM UNUSEDVAR(1) AS string
	print
	UINPUTS("PAUSED - PRESS 'ENTER' TO CONTINUE...", UNUSEDVAR)
	print
	ENDSUB
'==================================================================================================================
'-------------------- ARMBASIC EXTENSIONS ------------------ 2007-08-02
'==============================================================================
function i2h (long as integer) as string
	dim temp_str(16) as string
	temp_str = hex(long)
	return  left("$00000000",9-len(temp_str)) + temp_str
	endfunction
'==============================================================================
function i2b (long as integer) as string
	dim temp_str(48) as string
	dim bits_loop as integer
	temp_str = "&"
	for bits_loop = 31 downto 0
		temp_str = temp_str + str(bittest(long,bits_loop))
	next bits_loop
	return temp_str
	endfunction
'==============================================================================
function f2h (long as single) as string
	dim temp_str(8) as string
	temp_str = hex(*(addressof long))
	return  left("$00000000",9-len(temp_str)) & temp_str
	endfunction
'==============================================================================
function f2b (sing as single) as string
	dim temp_str(48) as string
	dim bits_loop as integer
	temp_str = "&"
	for bits_loop = 31 downto 0
		temp_str = temp_str + str(bittest(*(addressof sing),bits_loop))
	next bits_loop
	return temp_str
	endfunction
'==============================================================================
'-------------------- ASC Constructs ------------------ circa May 2012 - See 'beating on asc' file, and 'byref inquiry' file
'==============================================================================
function ASC(BYREF strg_NAME AS STRING) as integer  ' returns ascii value of first char in string
	return ((*(*(ADDRESSOF strg_NAME))) AND $FF)		'dbl deref kicked my arse
	endfunction
'==============================================================================
' while this is the most robust, I waste ram by dim'g too large a func var,
' or run the risk of a calling construct overflowing - too risky, imo.
function ASC1 (BYVAL strg(16) as string) as integer  ' returns ascii value of first char in string
	return ((*(addressof strg)) AND $FF)
	endfunction
'==============================================================================
' Byref works well, other than it doesn't deal with string constants at all.
' also I have to pass the address and not the var name.  it seems that the
' compiler could see provide the pointer without my having to provide it?
function ASC2(BYREF ADDR) as integer  ' returns ascii value of first char in string
	return ((*(ADDR)) AND $FF)
	endfunction
'==============================================================================
/* 
function ASC3(BYREF ADDR) as integer
	dim a as integer
	DIM B AS INTEGER
	a = addressof ADDR
	' B = *A
	' PRINT "BYREF VAR PASSED: ";STRG
	' PRINT IHEXL(ADDRESSOF STRG)
	' PRINT IHEXL(A)
	return 0
endfunction
 */
'==============================================================================
' #define ASCA(args...)	args     ' gotta recall what this might have been intended for...
#define ASCS(args...)	((*(ADDRESSOF args)) AND $FF)  ' ASC for variables only, not literals
'==============================================================================
' Save/Restore DDRs - need to vet for moar robust implementation (func vs. sub) & for x-device usability
' was used in a shared bus context, or possibly with the ABrtos effort of eons ago...
'==============================================================================
'global
'==================================================================================================================
function getddr(byref int_var as integer) as integer  'return/set var to ddr registers from mcu
	dim i as integer
	dim ddr as integer
	ddr = 0
	for i = 31 downto 0
		ddr = ((ddr<<1) or dir(i))
	next i
	int_var = ddr	' does this make sense, or is it bad juju????
	return ddr
	endfunction
'==================================================================================================================
function setddr(byref int_var as integer) as integer  'set var to ddr registers on mcu & return results
	dim i as integer
	for i = 0 to 31
		dir(i) = bittest(int_var,i)
	next i
	return getddr(int_var)  	' does this make sense, or is it bad juju????
	endfunction
'==============================================================================



#endif
