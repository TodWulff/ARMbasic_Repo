#ifndef FAT_spi
#define FAT_spi
#include "C:\MY_CODE\ARMBASIC\lib/ARMbasic_Extensions.lib"

#if enable_fat_verbose == 1
	#include "C:\MY_CODE\ARMBASIC\fat\FAT_Verbose_Error.lib"
#endif

#include "fat/FAT_defs.lib"

#if (enable_shared_spi_bus == 1) * (fat_on_shared_bus == 1)
	#define shared_fat 1
#else
	#define shared_fat 0
#endif

#define FAT_ARMBASIC_LIB_VER "F100AB"

'==============================================================================
'-------------------- UM-FAT SPI SUPPORT ROUTINES ------------------ 2007-07-04
'==============================================================================

DIM FAT_RESP_STR$(255)
DIM FAT_SEND_STR$(255)

DIM FAT_FILE_HANDLE AS INTEGER
DIM FAT_FILE_NAME(8) AS STRING
DIM FAT_FILE_EXT(3) AS STRING
DIM FAT_FILE_ATTR AS INTEGER
DIM FAT_FILE_SIZE AS INTEGER
DIM FAT_TIME AS INTEGER
DIM FAT_VERBOSE_TIME(21) AS STRING
DIM FAT_FILE_OPEN_MODE(1) AS STRING
DIM FAT_STRFLAG AS INTEGER
DIM FAT_VER_MOD_MAJOR AS INTEGER
DIM FAT_VER_MOD_MINOR AS INTEGER
DIM FAT_VER_LIB_MAJOR AS INTEGER
DIM FAT_VER_LIB_MINOR AS INTEGER
STRFLAG = 0
	
'==============================================================================

FUNCTION FAT_BUSY_QRY AS INTEGER

	DIM FAT_BUSY_STATE AS INTEGER

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

	FAT_BUSY_STATE = IN(FAT_BUSY) AND 1

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif
	
	RETURN FAT_BUSY_STATE

ENDFUNCTION

'==============================================================================

SUB FAT_WAIT_FOR_IDLE

	WHILE FAT_BUSY_QRY
	LOOP

ENDSUB

'==============================================================================

FUNCTION FAT_DRDY_QRY AS INTEGER

	DIM FAT_DRDY_STATE AS INTEGER

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

	FAT_DRDY_STATE = IN(FAT_DRDY) AND 1

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif
	
	RETURN FAT_DRDY_STATE
	
ENDFUNCTION

'==============================================================================

SUB FAT_WAIT_FOR_DRDY

	GOSUB FAT_WAIT_FOR_IDLE
	WHILE FAT_DRDY_QRY = LO
	LOOP

ENDSUB

'==============================================================================

FUNCTION FAT_GET_CHAR AS INTEGER
' HAVING TO BIT BANG SPIIN FAT_SSEL, FAT_MISO, FAT_SCLK, [FAT_RECV_CHAR] - TRIED SPIBI AND MANUAL SSEL AS WELL...

	DIM FAT_RECV_CHAR AS INTEGER
	
	GOSUB FAT_WAIT_FOR_IDLE
	GOSUB FAT_WAIT_FOR_DRDY

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

	FAT_RECV_CHAR = 0
	OUT(FAT_SCLK)=HI
	
	OUT(FAT_SSEL)=LO

' 		THIS IS 31MS
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)
	OUT(FAT_SCLK)=LO
	OUT(FAT_SCLK)=HI
	FAT_RECV_CHAR = (FAT_RECV_CHAR<<1) OR (IN(FAT_MISO) AND 1)

	OUT(FAT_SSEL)=HI
	
	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif
	
	RETURN FAT_RECV_CHAR

ENDFUNCTION

'==============================================================================

SUB FAT_SEND_CHAR (FAT_SEND_CH) '  (SSEL MUST BE PULLED LOW FOR WHOLE STRING!!!)

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

'	THIS TAKES 24uS
	SPIMODE 0
	SPIOUT -1, FAT_MOSI, FAT_SCLK, [FAT_SEND_CH]
	
	#if shared_fat == 1
		IF FAT_STRFLAG <> 1 THEN GOSUB RELEASE_SHARED_BUS
	#endif

ENDSUB

'==============================================================================

FUNCTION FAT_DELAY (FAT_DELAY_MS AS INTEGER)
' DELAYS THE MINIMUM DELAY (FAT_WAIT_TIME IF PARAMETER PASSSED = 0)
' OR A NUM OF MS AS ASSERTED BY THE PARAMETER PASSED
 
	DIM FAT_DELAY_START AS INTEGER
	DIM FAT_DLY_TIME AS INTEGER
	
	FAT_DLY_TIME = FAT_WAIT_TIME
	IF FAT_DELAY_MS THEN FAT_DLY_TIME = 1000 * FAT_DELAY_MS
	FAT_DELAY_START = TIMER
	WHILE TIMER-FAT_DELAY_START < FAT_DLY_TIME
	LOOP

ENDSUB

'==============================================================================

FUNCTION FAT_GET_RESP_STRG AS STRING
FAT_DEBUG(PRINT "GETTING RESPONSE STRING")	

	DIM FAT_RECV_CHAR AS INTEGER
	dim FAT_ERR_CHR$(3) as string
	dim FAT_ERR_CODE as integer

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

	GOSUB FAT_WAIT_FOR_DRDY
	WHILE FAT_DRDY_QRY

		FAT_RECV_CHAR = FAT_GET_CHAR
		IF (FAT_RECV_CHAR >= 10) AND (FAT_RECV_CHAR < 127) AND (FAT_RECV_CHAR <> 00) AND (FAT_RECV_CHAR <> 33) THEN FAT_RESP_STR$ = FAT_RESP_STR$ & CHR(FAT_RECV_CHAR)
		IF (FAT_RECV_CHAR = 33) THEN
		#if enable_fat_verbose != 1
				FAT_RESP_STR$ = FAT_RESP_STR$ & CHR(FAT_RECV_CHAR)
			ENDIF
		#else
				FAT_RECV_CHAR = FAT_GET_CHAR
				FAT_ERR_CHR$ = "$" & CHR(FAT_RECV_CHAR)
				FAT_RECV_CHAR = FAT_GET_CHAR
				FAT_ERR_CHR$ = FAT_ERR_CHR$ & CHR(FAT_RECV_CHAR)
				FAT_ERR_CODE = VAL(FAT_ERR_CHR$)	
FAT_DEBUG(PRINT "ERR CODE: ";FAT_ERR_CODE)
FAT_DEBUG(FAT_ERR_CODE = 254)
				FAT_TEMP$ = FAT_GET_ERR_STG(FAT_ERR_CODE)
FAT_DEBUG(PRINT "ERR STRING: ";FAT_TEMP$)
				FAT_RESP_STR$ = FAT_RESP_STR$ + FAT_TEMP$
			ENDIF
		#endif
	LOOP															' TO BUILD STRING - INCLUDES EMBEDDED CHARACTERS AS WELL...

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif

	RETURN FAT_RESP_STR$

ENDFUNCTION

'==============================================================================

SUB FAT_DISP_RESP

	PRINT FAT_RESP_STR$
	FAT_RESP_STR$=""
	PRINT

ENDSUB

'==============================================================================

SUB FAT_SEND_STRING (FAT_SEND_STR(255) AS STRING)

	DIM FAT_SEND_STRG_LOOP AS INTEGER
	DIM FAT_SEND_CH AS INTEGER

	GOSUB FAT_WAIT_FOR_IDLE

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

	FAT_SEND_STR = FAT_SEND_STR & CHR(FAT_EOL)  ' APPEND A <CR> TO THE END OF THE STRING

	OUT(FAT_SSEL)=LO		' BIT BANG THE SPI SSEL SENDSTRING$ FUNCTIONALITY...
	
	FAT_STRFLAG = 1
	
	FOR FAT_SEND_STRG_LOOP=0 TO LEN(FAT_SEND_STR)-1
FAT_DEBUG(PRINT ".";CHR(FAT_SEND_STR(FAT_SEND_STRG_LOOP));)
		GOSUB FAT_SEND_CHAR(FAT_SEND_STR(FAT_SEND_STRG_LOOP))
	NEXT FAT_SEND_STRG_LOOP
	
	FAT_STRFLAG = 0
	
	OUT(FAT_SSEL)=HI

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif

ENDSUB

'==============================================================================

SUB FAT_INIT

	#if enable_fat_verbose == 1
		GOSUB FAT_ERR_INIT
	#endif

	DIR(FAT_RSET) = OUTP		' RESET - STROBE LOW TO RESET UALFAT
	OUT(FAT_RSET) = HI

	DIR(FAT_SSEL) = OUTP		' SELECT FOR SPI BUS
	DIR(FAT_MOSI) = OUTP		' MOSI FOR SPI BUS
	DIR(FAT_MISO) = INPT		' MISO FOR SPI BUS
	DIR(FAT_SCLK) = OUTP		' CLOCK FOR SPI BUS

	DIR(FAT_DRDY) = INPT		' DATA READY HANDSHAKING SIGNAL FOR SPI BUS
	DIR(FAT_BUSY) = INPT		' BUSY HANDSHAKING SIGNAL FOR SPI BUS

	#if shared_fat == 1
		DIR(SHARED_BUS_REQ) = OUTP
		OUT(SHARED_BUS_REQ) = LO
	    DIR(SHARED_BUS_ACK) = INPT
		GOSUB SEIZE_SHARED_BUS
	#endif

	OUT(FAT_SSEL) = HI			' SSEL AND SCLK HAVE TO BE HIGH AT RESET FOR SPI TO BE THE COMM MODE...
	OUT(FAT_SCLK) = HI

	OUT(FAT_RSET) = LO
	CALL FAT_DELAY(0)
	OUT(FAT_RSET) = HI
	CALL FAT_DELAY(0)
	

' THERE IS A GOOFY SYNC ISSUE WITH THE VERY FIRST COMMAND;
' THIS IS A HACK FIX, BUT HEY, IT WORKS...

	CALL FAT_DELAY(10)
	GOSUB FAT_WAIT_FOR_DRDY
	GOSUB FAT_GET_RESP_STRG
	GOSUB FAT_DISP_RESP
	GOSUB FAT_SEND_STRING("")
	GOSUB FAT_GET_RESP_STRG
	FAT_RESP_STR$ = ""

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif
	
FAT_DEBUG(PRINT "FAT INIT DONE")	

ENDSUB

'==============================================================================

FUNCTION FAT_GET_LIBRARY_VERSION AS STRING

	RETURN FAT_ARMBASIC_LIB_VER

ENDFUNCTION

' ==============================================================================

SUB FAT_START_BOOTLOADER

	GOSUB FAT_SEND_STRING("X M")

ENDSUB

' ==============================================================================

SUB FAT_LOAD_SD_FW

	GOSUB FAT_SEND_STRING("X S")

ENDSUB

' ==============================================================================

SUB FAT_LOAD_USB_FW

	GOSUB FAT_SEND_STRING("X U")

ENDSUB

' ==============================================================================

SUB FAT_HIBERNATE

'	GOSUB FAT_SEND_STRING("Z H")

ENDSUB

' ==============================================================================

FUNCTION FAT_GET_RESULT AS INTEGER

	DIM FAT_RESULT AS INTEGER

	GOSUB FAT_WAIT_FOR_IDLE
	GOSUB FAT_WAIT_FOR_DRDY
	
FAT_GET_NUTHA_CHAR:

	FAT_RESULT = FAT_GET_CHAR
	IF FAT_RESULT <> "!" THEN ' RETURN ERROR_UNEXPECTED_VALUE

		PRINT "(NOT !: ";FAT_RESULT;") ";
		GOTO FAT_GET_NUTHA_CHAR
	ENDIF
	
	FAT_RESULT = VAL("$" & CHR(FAT_GET_CHAR) & CHR(FAT_GET_CHAR))
	IF FAT_GET_CHAR <> $0D THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_RESULT
	
ENDFUNCTION

' ==============================================================================


FUNCTION FAT_INITIALIZE_SD AS INTEGER

	DIM FAT_RESULT AS INTEGER

	GOSUB FAT_SEND_STRING("I")
	GOSUB FAT_WAIT_FOR_DRDY
	IF FAT_GET_CHAR <> 6 THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_INITIALIZE_USB AS INTEGER

	GOSUB FAT_SEND_STRING("U")
	GOSUB FAT_WAIT_FOR_DRDY
	IF FAT_GET_CHAR <> 6 THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_GET_MODULE_VERSION AS INTEGER

	DIM FAT_RESULT AS INTEGER
	DIM FAT_CHAR AS INTEGER

	GOSUB FAT_SEND_STRING("V")
	GOSUB FAT_WAIT_FOR_DRDY
	IF FAT_GET_CHAR <> 134 THEN RETURN ERROR_UNEXPECTED_VALUE
	
	' DUMP THE UNNEEDED PARTS OF THE STRING...
	CALL FAT_GET_CHAR ' u
	CALL FAT_GET_CHAR ' A
	CALL FAT_GET_CHAR ' L
	CALL FAT_GET_CHAR ' F
	CALL FAT_GET_CHAR ' A
	CALL FAT_GET_CHAR ' T
	CALL FAT_GET_CHAR ' SPACE

	FAT_CHAR = FAT_GET_CHAR
	CALL FAT_GET_CHAR ' PERIOD
	FAT_RESULT = VAL(CHR(FAT_CHAR) & CHR(FAT_GET_CHAR) & CHR(FAT_GET_CHAR))
	IF FAT_GET_CHAR <> $0D THEN RETURN ERROR_UNEXPECTED_VALUE
	IF FAT_GET_RESULT <> 0 THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_RESULT

ENDFUNCTION

' ==============================================================================
/*
SUB FAT_TOGGLE_WAKE_PIN

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

' PUT CODE HERE TO TOGGLE THE WAKE PIN - NEEDED IF YOU PUT IT INTO HEIBERNATE...

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif

ENDSUB

' ==============================================================================

FUNCTION FAT_WAKE_MODULE AS INTEGER

	#if shared_fat == 1
		GOSUB SEIZE_SHARED_BUS
	#endif

'	GOSUB FAT_TOGGLE_WAKE_PIN
'	RETURN FAT_GET_RESULT

	#if shared_fat == 1
		GOSUB RELEASE_SHARED_BUS
	#endif

ENDFUNCTION
*/
' ==============================================================================

FUNCTION FAT_CHANGE_DIR (BYREF FAT_FILE_NAME AS STRING) AS INTEGER

	GOSUB FAT_SEND_STRING("A " & FAT_FILE_NAME)
	GOSUB FAT_WAIT_FOR_DRDY
	IF FAT_GET_CHAR <> 134 THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_MAKE_DIR (BYREF FAT_FILE_NAME AS STRING) AS INTEGER

	GOSUB FAT_SEND_STRING("M " & FAT_FILE_NAME)
	GOSUB FAT_WAIT_FOR_DRDY
	IF FAT_GET_CHAR <> 134 THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_OPEN_FILE (FAT_FILE_HANDLE AS INTEGER, BYREF FAT_FILE_OPEN_MODE AS STRING, BYREF FAT_FILE_NAME AS STRING, BYREF FAT_FILE_EXT AS STRING) AS INTEGER

	GOSUB FAT_SEND_STRING("O " & STR(FAT_FILE_HANDLE) & FAT_FILE_OPEN_MODE & ">" & FAT_FILE_NAME & "." & FAT_FILE_EXT)
	GOSUB FAT_WAIT_FOR_DRDY
	IF FAT_GET_CHAR <> 6 THEN RETURN ERROR_UNEXPECTED_VALUE
	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================
/*
FUNCTION FAT_GET_FILE_INIT AS INTEGER

	GOSUB FAT_SEND_STRING("@")
	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_GET_NEXT_FILE (BYREF FAT_FILE_NAME AS STRING, BYREF FAT_FILE_EXT AS STRING, FAT_FILE_ATTR AS INTEGER, FAT_FILE_SIZE AS INTEGER) AS INTEGER 

	DIM C AS INTEGER
	
	GOSUB FAT_SEND_STRING("N")
	C = FAT_GET_RESULT
	if C THEN RETURN C
	
	FOR C = 0 TO 7
		FAT_FILE_NAME(C)=FAT_GET_CHAR
	NEXT C	
	
	IF FAT_GET_CHAR <> $2E THEN RETURN ERROR_UNEXPECTED_VALUE	' EXPECT A . TO SEPARATE FILE NAME AND FILE EXT
		
	FOR C = 0 TO 2
		FAT_FILE_EXT(C)=FAT_GET_CHAR
	NEXT C	

	IF FAT_GET_CHAR <> $20 THEN RETURN ERROR_UNEXPECTED_VALUE

	FAT_FILE_ATTR = VAL("$" & FAT_GET_CHAR & FAT_GET_CHAR)

	IF FAT_GET_CHAR <> $20 THEN RETURN ERROR_UNEXPECTED_VALUE
	
	FAT_FILE_SIZE = VAL("$" & FAT_GET_CHAR & FAT_GET_CHAR & FAT_GET_CHAR & FAT_GET_CHAR & FAT_GET_CHAR & FAT_GET_CHAR & FAT_GET_CHAR & FAT_GET_CHAR)
	
	IF FAT_GET_CHAR <> $0D THEN RETURN ERROR_UNEXPECTED_VALUE
	
	RETURN FAT_GET_RESULT
	
ENDFUNCTION

' ==============================================================================

FUNCTION FAT_BUILD_FATTIME (YEAR AS INTEGER, MONTH AS INTEGER, DAY AS INTEGER, HOUR AS INTEGER, MINUTE AS INTEGER, SECOND AS INTEGER) AS INTEGER

	RETURN (((YEAR-1980) AND $7F) << 25) OR ((MONTH AND $0F) << 21) OR ((DAY AND $1F) << 16) OR ((HOUR AND $1F) << 11) OR (( MINUTE AND $3F) << 5) OR ((SECONDS/2) AND $1F)

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_GET_TIME AS INTEGER

	DIM C AS INTEGER
	DIM TEMP(8) AS STRING
	
	GOSUB FAT_SEND_STRING("G X")

	C = FAT_GET_RESULT
	IF C THEN RETURN C
	
	IF FAT_GET_CHAR <> "$" THEN RETURN ERROR_UNEXPECTED_VALUE

	FOR C = 0 TO 7
		TEMP(C)=FAT_GET_CHAR
	NEXT C
	
	FAT_TIME = VAL("$" & TEMP)

	IF FAT_GET_CHAR <> $0D THEN RETURN ERROR_UNEXPECTED_VALUE

	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_INIT_TIMER (BACKUP AS INTEGER) AS INTEGER

	IF BACKUP THEN
		GOSUB FAT_SEND_STRING("T B")
	ELSE
		GOSUB FAT_SEND_STRING("T S")
	ENDIF

	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_FLUSH_FILE (FILE_HANDLE AS INTEGER) AS INTEGER

	GOSUB FAT_SEND_STRING("F " & STR(FILEHANDLE))

	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_SEND_WRITE_CMD (FILE_HANDLE AS INTEGER, REQ_DATA_SIZE AS INTEGER) AS INTEGER

	GOSUB FAT_SEND_STRING("W " & STR(FILEHANDLE) & ">" & STR(HEX(REQ_DATA_SIZE)))

	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_DEL_FILE (BYREF FAT_FILE_NAME AS STRING) AS INTEGER

	GOSUB FAT_SEND_STRING("D " & FAT_FILE_NAME)

	RETURN FAT_GET_RESULT

ENDFUNCTION

' ==============================================================================

FUNCTION FAT_


	RETURN FAT_GET_RESULT

ENDFUNCTION
*/

#endif
